# Архитектура: RBAC, павильоны и главная страница

Документ описывает целевую архитектуру ролей, доступа по павильонам и единой главной страницы. Детальный код не приводится — только модели, контракты и порядок реализации.

---

## 1. Целевые роли и соответствие текущей схеме

| Целевая роль   | Текущий enum              | Описание |
|----------------|---------------------------|----------|
| **ADMIN**      | ROLE_ADMIN                | Полный доступ: оба павильона, пользователи, настройки, отчёты, финансы, история. |
| **MANAGER**    | ROLE_MANAGER              | Оба павильона, отчёты, финансы. Не может: управлять пользователями, менять системные настройки. |
| **OPERATOR_P1** | ROLE_OPERATOR            | Только павильон 1: форма документов, свои заявки. Не видит: финансы, павильон 2, пользователей, настройки. |
| **OPERATOR_P2** | ROLE_PLATE_OPERATOR      | Только павильон 2: изготовление номеров, касса номеров, склад. Не видит: павильон 1 (форма), управление пользователями, общие финансы павильона 1. |

Система должна быть расширяемой: новые роли добавляются в enum и в матрицу прав без переписывания всей логики.

---

## 2. Модели (концептуально)

### 2.1 Пользователь (уже есть)

- **Employee** (таблица `employees`): id, name, role (enum), login, password_hash, is_active, telegram_id, created_at.
- Роль хранится в колонке `role` как значение enum. Отдельной таблицы ролей не требуется: роли фиксированы в коде, enum расширяется при добавлении новой роли.

### 2.2 Роль

- **Роль** — значение enum `EmployeeRole`. Отдельная модель/таблица не вводится.
- В коде задаётся:
  - какие **павильоны** доступны роли (1, 2 или оба);
  - какие **разделы** доступны (форма, касса P1, касса P2, склад, отчёты, пользователи, настройки, финансы, история).
- Расширяемость: новый enum-значение + обновление матрицы прав (см. ниже).

### 2.3 Павильон

- **Павильон** — константа контекста, не отдельная таблица в БД.
- Два значения: **1** (документы), **2** (изготовление номеров).
- В API и на фронте передаётся как число (1 или 2) или query/body-параметр `pavilion`.
- Для операторов павильон однозначно задаётся ролью (P1 → только 1, P2 → только 2). Для ADMIN/MANAGER павильон выбирается пользователем (текущий контекст).

---

## 3. Матрица прав (роль × ресурс)

Ресурсы — это типы данных и действий, а не URL. Пример матрицы:

| Ресурс / Действие           | ADMIN | MANAGER | OPERATOR_P1 | OPERATOR_P2 |
|----------------------------|-------|---------|-------------|-------------|
| Павильон 1 (форма, заказы) | ✓     | ✓       | ✓           | —           |
| Павильон 2 (номера, склад) | ✓     | ✓       | —           | ✓           |
| Касса павильона 1          | ✓     | ✓       | ✓           | —           |
| Касса павильона 2          | ✓     | ✓       | —           | ✓           |
| Склад заготовок            | ✓     | ✓       | —           | ✓           |
| Отчёты / аналитика         | ✓     | ✓       | —           | —           |
| Финансы (сводки)           | ✓     | ✓       | —           | —           |
| Управление пользователями  | ✓     | —       | —           | —           |
| Системные настройки        | ✓     | —       | —           | —           |
| История изменений / аудит  | ✓     | —       | —           | —           |
| Переключение павильона     | ✓     | ✓       | —           | —           |

«Видит павильон» = может открыть раздел и вызывать API этого павильона. Проверка на бэкенде обязательна для каждого эндпоинта, который привязан к павильону или к чувствительным данным.

---

## 4. Логика авторизации на бэкенде

### 4.1 Текущее состояние

- JWT с полями: sub (id пользователя), name, role, login.
- Зависимости вида `RequireFormAccess`, `RequireOrdersListAccess`, `RequirePlateAccess`, `RequireAnalyticsAccess`, `RequireAdmin`, `RequireCashAccess` — каждая проверяет вхождение роли в список разрешённых.
- Привязки к павильону нет: доступ к кассе/заказам различается по разным эндпоинтам (orders vs plate-list, cash/rows vs cash/plate-rows), но явного параметра «павильон пользователя» в проверках нет.

### 4.2 Целевая архитектура

1. **Единый слой прав (Permission Service / проверки)**  
   - Один модуль (например `app.core.permissions` или `app.services.permission_service`), где по роли и опционально по павильону возвращается: может ли пользователь выполнить действие над ресурсом.
   - Функции вида: `can_access_pavilion(role, pavilion)`, `can_access_resource(role, resource_name)`, `can_manage_users(role)`.
   - Ресурсы заданы константами или enum’ом (FORM_P1, PLATES_P2, CASH_P1, CASH_P2, WAREHOUSE, ANALYTICS, USERS, SETTINGS, AUDIT).

2. **Зависимости FastAPI (Depends)**  
   - Оставить получение текущего пользователя из JWT в одном месте (например `get_current_user` → `UserInfo`).
   - Вместо набора разных `Require*` ввести одну обобщённую зависимость, например:  
     `RequirePermission(resource, allowed_pavilions=None)`  
     — внутри вызывает permission service и при необходимости проверяет переданный в запросе `pavilion` (query/body/path) против роли пользователя.
   - Для обратной совместимости старые `RequireFormAccess` и т.д. можно оставить как тонкие обёртки над новой проверкой.

3. **Проверка павильона в API**  
   - Эндпоинты, которые привязаны к павильону (касса, заказы павильона 2, склад), получают `pavilion` из query/body/path.
   - Middleware или зависимость проверяет: для данной роли доступен ли этот павильон; для OPERATOR_P1 разрешён только 1, для OPERATOR_P2 — только 2.
   - Если павильон не передан — для ADMIN/MANAGER можно подставлять значение по умолчанию или возвращать 400; для операторов — использовать единственный разрешённый павильон.

4. **Фильтрация данных по павильону**  
   - Списки заказов, кассовые строки и т.д. на бэкенде фильтруются по павильону там, где это применимо (например заказы «павильона 2» — с need_plate или по типу; касса — по pavilion в таблице смен/строк).
   - Оператор никогда не получает данные чужого павильона: это гарантируется на уровне выборки (QuerySet/select), а не только скрытием кнопок на фронте.

---

## 5. Главная страница и навигация

### 5.1 Структура главной страницы

- **Один входной URL** (например `/` или `index.html`), который открывается после логина для всех ролей.
- **Верхняя панель (header):**
  - Слева: логотип или название системы.
  - По центру или слева от меню: **название текущего павильона**. Если у роли доступно несколько павильонов (ADMIN, MANAGER) — выпадающий список переключения; при выборе меняется контекст (какой павильон «текущий») и контент основной части.
  - Кнопка **«Быстрое создание»** (создание заявки/документа) — видна только если у пользователя есть доступ к форме павильона 1; для павильона 2 может быть другой первичный экшен (например «Список заказов»).
  - Справа: **меню (иконка «три точки» или бургер)**. По клику открывается выпадающее меню; пункты зависят от роли и текущего павильона.

- **Основная часть (main):**
  - Если выбран **павильон 1**: форма создания документа + блок «Последние 10 заявок» текущего павильона (только те, что относятся к павильону документов).
  - Если выбран **павильон 2**: список заказов с номерами (как сейчас plate-operator) + при необходимости краткий блок последних действий.
  - Один layout, разное содержимое в зависимости от роли и выбранного павильона.

### 5.2 Содержимое меню по ролям

Меню рендерится динамически: после логина фронт запрашивает у бэкенда «меню для текущего пользователя» (например `GET /auth/me` возвращает роль и список разрешённых пунктов меню, или отдельный `GET /auth/menu`).

Примерная логика:

- **ADMIN:** Управление пользователями, Настройки, Отчёты, Финансы, История изменений, Смена пароля, Выход. Плюс при необходимости пункты «Павильон 1» / «Павильон 2» как быстрые переключатели контекста.
- **MANAGER:** Отчёты, Финансы, Смена пароля, Выход. Переключение павильона — через выпадающий список в шапке, не обязательно в меню.
- **OPERATOR_P1:** Смена пароля, Выход. Без переключения павильона (доступен только один).
- **OPERATOR_P2:** Смена пароля, Выход.

Конкретный список пунктов и их видимость задаются на бэкенде (по роли) и отдаются в ответе `auth/me` или `auth/menu`, чтобы не дублировать матрицу прав на фронте.

---

## 6. State management (фронтенд)

### 6.1 Минимальный глобальный state

- **user:** { id, name, role, login } — после логина, из JWT или из `GET /auth/me`.
- **currentPavilion:** 1 | 2 — выбранный павильон (для ADMIN/MANAGER); для операторов задаётся один раз по роли и не меняется.
- **menuItems:** список пунктов меню (получен с бэкенда или построен по роли на фронте по единому контракту).

Хранить можно в одном глобальном объекте (например `window.appState`) или в отдельном небольшом модуле; при отсутствии фреймворка — простой объект + функции set/get.

### 6.2 Инициализация после входа

1. После успешного логина сохранить токен, вызвать `GET /auth/me` (или расширенный эндпоинт с меню).
2. По ответу выставить: user, список пунктов меню, разрешённые павильоны.
3. Установить currentPavilion: для OPERATOR_P1 = 1, для OPERATOR_P2 = 2; для ADMIN/MANAGER — по умолчанию 1 (или последний сохранённый в localStorage).
4. Рендер: шапка с переключателем павильона (если разрешено), кнопка быстрого создания (если есть право), меню по пунктам из state.

### 6.3 Переключение павильона

- При смене значения в выпадающем списке обновлять `currentPavilion` и перерисовывать основную часть (форма P1 vs список заказов P2).
- Опционально сохранять выбор в localStorage, чтобы при следующем входе MANAGER/ADMIN видел последний выбранный павильон.

---

## 7. API: контракты и проверки

### 7.1 Эндпоинт текущего пользователя и меню

- **GET /auth/me** (или расширенный вариант): возвращает не только id, name, role, login, но и:
  - `allowed_pavilions`: [1], [2] или [1, 2];
  - `menu_items`: [ { id, label, href or action, visible } ] — чтобы фронт не хранил матрицу прав для меню.

Либо отдельный **GET /auth/menu** с тем же форматом списка пунктов.

### 7.2 Единообразие проверок

- Каждый эндпоинт, возвращающий или изменяющий данные павильона, должен:
  1. Получить текущего пользователя (JWT).
  2. Получить павильон из запроса (если применимо).
  3. Вызвать централизованную проверку: эта роль имеет ли право на этот ресурс/павильон; при несоответствии — 403.
  4. Фильтровать выборки по павильону там, где данные привязаны к павильону.

### 7.3 Список «последние 10 заявок»

- Новый эндпоинт или расширение существующего, например:  
  **GET /orders?pavilion=1&limit=10**  
  — возвращает последние заказы павильона 1 (по смыслу — заказы, созданные через форму документов). Бэкенд проверяет право на павильон 1 и отдаёт только разрешённые данные.

---

## 8. Расширяемость ролей

- Добавление новой роли: новое значение в enum `EmployeeRole`, миграция БД (если enum хранится в PostgreSQL).
- В модуле прав добавить роль в матрицу: для каждого ресурса указать, разрешён ли доступ.
- При необходимости добавить правило «доступные павильоны» для новой роли.
- Меню для новой роли задаётся в том же месте, где формируется список пунктов (бэкенд или общий конфиг на бэкенде).
- Фронт меню не зашивает: получает готовый список из API, поэтому новая роль не требует правок разметки меню, только бэкенд.

---

## 9. План реализации (по шагам)

### Фаза 1: Бэкенд — права и павильоны

1. Ввести модуль прав (permission service): матрица роль × ресурс, функции `can_access_*`, привязка ролей к павильонам.
2. Расширить **GET /auth/me** (или добавить **GET /auth/menu**): возвращать `allowed_pavilions` и `menu_items` по роли.
3. Ввести зависимость/декоратор проверки «ресурс + павильон» и постепенно подключать к существующим эндпоинтам (orders, cash, warehouse, analytics, employees, price_list).
4. Добавить фильтрацию по павильону в тех выборках, где это ещё не сделано (например список заказов для главной).
5. Эндпоинт «последние N заявок павильона» с проверкой права на этот павильон.

### Фаза 2: Фронт — единая главная и меню

1. Сделать одну главную страницу (например `index.html` после логина): шапка с переключателем павильона (для тех, у кого оба), кнопка быстрого создания, меню (три точки).
2. Меню рендерить из ответа API (auth/me или auth/menu): один и тот же компонент выпадающего списка, пункты приходят с бэкенда.
3. Основная область: для павильона 1 — форма + блок «Последние 10 заявок» (данные с нового/расширенного API); для павильона 2 — текущий функционал plate-operator (список заказов с номерами).
4. State: user, currentPavilion, menuItems; инициализация после логина, сохранение currentPavilion в localStorage для ADMIN/MANAGER.

### Фаза 3: Приведение старых страниц к новой навигации

1. Страницы account, admin, users, cash-shifts, plate-cash, warehouse остаются как отдельные экраны, но доступ к ним только через пункты меню (и по прямой ссылке — бэкенд вернёт 403 при недостатке прав).
2. Убрать дублирование навбара из старых страниц: общий header с меню подключать с одной разметки или одного JS, чтобы меню и переключатель павильона были едиными.
3. Редирект после логина всегда на главную (`/` или `index.html`); с главной пользователь переходит в нужный раздел через меню или контент главной.

### Фаза 4: Доработки и документация

1. Тесты: проверка, что OPERATOR_P1 не получает данные павильона 2 и не может вызвать эндпоинты павильона 2; то же для OPERATOR_P2; MANAGER видит оба павильона, но не пользователей; ADMIN видит всё.
2. Обновить USER_GUIDE и при необходимости INSTALL: описание ролей, входа на главную, переключения павильона и пунктов меню.

---

## 10. Резюме

- **Роли:** ADMIN, MANAGER, OPERATOR_P1, OPERATOR_P2 — маппинг на текущий enum, без отдельной таблицы ролей; расширение — новое значение enum + обновление матрицы прав.
- **Павильон:** контекст 1 или 2, не таблица; для операторов задаётся ролью, для ADMIN/MANAGER — выбор пользователя.
- **Права:** централизованный слой (permission service) + единая проверка в API (ресурс + павильон); данные фильтруются по павильону на бэкенде.
- **Главная:** один экран с шапкой (название/переключатель павильона, быстрый экшен, меню «три точки») и основной частью (форма P1 + последние заявки или список P2).
- **Меню:** формируется на бэкенде по роли, отдаётся в auth/me или auth/menu; фронт рендерит пункты динамически.
- **State:** user, currentPavilion, menuItems; инициализация после логина, переключение павильона с сохранением в localStorage при необходимости.

После утверждения этой архитектуры можно переходить к поэтапной реализации по фазам 1–4.
