# Общие архитектурные правила проекта eye_w (Django-слой)

Этот файл дополняет существующие правила в `.cursor/rules/*.mdc` и фиксирует принципы для новой части системы на Django ORM.

## 1. Стек и границы ответственности

- **Backend (исторический)**: FastAPI + SQLAlchemy (папка `backend/app`) — не ломать существующие эндпоинты без явного плана миграции.
- **Новый слой**: Django ORM + сервисные классы — для учёта документов, платежей, кассы и склада.
- **Форма оператора**: остаётся источником данных (`OrderCreate`), поля не меняем без обновления `PROJECT_CONTEXT.md` и `DevelopmentDiary.md`.
- **Docx**: генерация документов обязана использовать существующий `docx_service` и `PLACEHOLDER_TO_FIELD`.

## 2. Статусы и бизнес-правила

- Статусы документа **разделены**:
  - `financial_status` — рассчитывается только из суммы платежей и `total_amount` (`UNPAID`, `PARTIALLY_PAID`, `FULLY_PAID`, `OVERPAID`).
  - `operational_status` — отражает жизненный цикл документа (`CREATED`, `READY_FOR_PAYMENT`, `IN_PROGRESS`, `SENT_TO_PRODUCTION`, `IN_PRODUCTION`, `PRODUCED`, `COMPLETED`, `CANCELLED`, `PROBLEM`).
- **Запрещено**:
  - изменять `financial_status` вручную;
  - изменять `operational_status` напрямую из контроллеров, сигналов, задач и скриптов.
- **Разрешено**:
  - менять статусы только через методы сервисного слоя (например, `DocumentService`, `PaymentService`), где явно зашиты проверки и инварианты.

## 3. Запрет бизнес-логики во view/контроллерах

- В Django:
  - классические `views`, DRF `ViewSet` и любые обработчики HTTP **не содержат бизнес-логики**:
    - нельзя в них менять статусы;
    - нельзя там считать суммы, долги, остатки;
    - нельзя напрямую создавать кассовые и складские транзакции.
- Контроллеры:
  - принимают и валидируют вход (схемы/serializers),
  - вызывают методы сервисов,
  - возвращают результат (DTO/serializers).

## 4. Правило атомарных транзакций

- Все операции, которые затрагивают:
  - документ и его статусы,
  - платежи,
  - кассовые транзакции,
  - складские транзакции,
должны выполняться **внутри одной атомарной транзакции БД**.

- Нельзя:
  - в одном HTTP-запросе сделать несколько независимых `save()` без `transaction.atomic`;
  - оставлять систему в состоянии, когда часть изменений записана, а часть — нет.

- Примеры обязательной атомарности:
  - «Принять оплату» — создание `Payment` + обновление `financial_status` документа.
  - «Оплата + изменение статуса» — создание `Payment` + перевод `operational_status`.
  - В будущем: «Перевод в производство» — изменение статуса + резерв/списание склада.

## 5. Расчёт financial_status

- `financial_status` не хранит произвольные значения, а всегда вычисляется и/или валидируется по инварианту:
  - `UNPAID` — `sum(payments) == 0`.
  - `PARTIALLY_PAID` — `0 < sum(payments) < total_amount`.
  - `FULLY_PAID` — `sum(payments) == total_amount`.
  - `OVERPAID` — `sum(payments) > total_amount`.
- Любой сервис, который меняет платежи, обязан:
  - пересчитывать `sum(payments)` для документа;
  - обновлять `financial_status` в соответствии с правилом выше.

## 6. Миграции и эволюция схемы

- Любое изменение моделей Django:
  - сначала описывается в `DevelopmentDiary.md`,
  - затем сопровождается миграцией (`migrations/*.py`),
  - только после этого используется в коде.
- Нельзя:
  - править схему БД вручную (через SQL) без миграций;
  - удалять поля/таблицы без явного плана миграции и фиксации в дневнике.

